# Dynamic Programming

> 복잡한 문제를 더 작은 하위 문제로 나누어 해결하는 알고리즘 설계 기법

## 조건

1. 중복되는 부분 

- 문제를 나누고 그 문제의 결과 값을 재활용해서 전체 답을 구한다.
- 동일한 작은 문제들이 반복하여 나타나는 경우에 사용이 가능하다.

2. 최적 부분 구조

- 부분 문제의 최적 결과 값을 사용해 전체 문제의 최적 결과를 낼 수 있는 경우 사용 가능하다.

## 방법

1. 📝메모하기

- 변수 값에 따른 결과를 저장할 배열 등을 미리 만들고 그 결과를 나올 떄마다 배열 내에 저장. 저장된 값을 재사용하는 방식으로 문제를 해결해 나간다.

2. 🧮변수 간 관계식(점화식) 만들기 -피보나치 수열 f(n) = f(n-1) + f(n-2)

## 문제 해결 방식

1. Bottom-Up (Tabulation 방식) - 반복문 사용

- 작은 부분 문제부터 차례대로 해결하여 전체 문제를 해결. 반복문을 사용하여 반복적으로 부분문제를 해결하고, 결과는 배열등에 저장함
- 배낭 문제(Knapsack Problem)
- 최장 증가 부분 수열
- 최단 경로 문제
- 문자열 편집 거리 문제

2. Top-Down (Memoization 방식) - 재귀 사용

- 큰 문제를 작은 부분 문제로 나누어 해결하는 방식. 재귀 함수를 사용하여 문제를 작은 부분 문제들로 쪼개고, 중복 계산을 피하기 위해 이전에 계산한 값을 저장하는 Memoization을 활용. Memoization은 캐싱을 통해 이전 계산 결과를 저장하여 중복 계산을 피하는 것을 의미함
- 피보나치 수열열

## 대표적인 DP 문제들

특정 데이터 내 최대화/최소화로 계산하거나
특정 조건 내 데이터를 세야 하거나
확률 등의 계산을 해야하는 경우

### 장점

중복 계산을 줄일 수 있다.
효율적인 시간 복잡도를 가질 수 있다.

### 단점

메모리 사용량이 크다. DP는 중간 결과를 저장하기 위해 추가적인 메모리를 사용, 따라서 문제의 크기가 커질수록 필요한 메모리도 증가할 수 있다.
